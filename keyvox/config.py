"""Configuration management for Keyvox."""
import os
import sys
import tomllib
from pathlib import Path
from typing import Dict, Any


DEFAULT_CONFIG = {
    "model": {
        "name": "large-v3-turbo",
        "device": "cuda",
        "compute_type": "float16",
        "backend": "auto",
    },
    "audio": {
        "input_device": "default",
        "sample_rate": 16000,
    },
    "hotkey": {
        "push_to_talk": "ctrl_r",
    },
    "paths": {
        "storage_root": "",
        "model_cache": "",
        "history_db": "",
    },
    "output": {
        "auto_paste": True,
        "paste_method": "type",
        "double_tap_to_clipboard": True,
        "double_tap_timeout": 0.5,
    },
    "dictionary": {},
    "text_insertion": {
        "enabled": True,
        "smart_capitalization": True,
        "smart_spacing": True,
        "normalize_urls": True,
        "www_mode": "explicit_only",
        "add_trailing_space": False,
        "context_max_chars": 100,
        "sentence_enders": ".!?",
        "punctuation_starters": ",.!?:;'\")}]",
    },
}


def _merge_configs(base: Dict[str, Any], overrides: Dict[str, Any]) -> Dict[str, Any]:
    """Recursively merge configuration dictionaries."""
    result = base.copy()
    for key, value in overrides.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = _merge_configs(result[key], value)
        else:
            result[key] = value
    return result


def _config_dirs() -> list[Path]:
    """Return platform-specific config directories, highest priority first."""
    dirs = [Path.cwd()]

    if os.name == "nt":
        # Windows: %APPDATA%\keyvox
        appdata = os.getenv("APPDATA")
        if appdata:
            dirs.append(Path(appdata) / "keyvox")
    elif sys.platform == "darwin":
        # macOS: ~/Library/Application Support/keyvox
        dirs.append(Path.home() / "Library" / "Application Support" / "keyvox")
    else:
        # Linux/other: $XDG_CONFIG_HOME/keyvox or ~/.config/keyvox
        xdg = os.getenv("XDG_CONFIG_HOME", str(Path.home() / ".config"))
        dirs.append(Path(xdg) / "keyvox")

    return dirs


def _find_config_path() -> Path | None:
    """Find config.toml in CWD or platform config directory."""
    for directory in _config_dirs():
        config_path = directory / "config.toml"
        if config_path.exists():
            return config_path
    return None


def get_config_path() -> Path | None:
    """Return the resolved config file path, if any."""
    return _find_config_path()


def get_platform_config_dir() -> Path:
    """Return the platform-specific config directory (never CWD).

    This is the stable location used for saving config so it can be found
    regardless of the working directory (e.g. when spawned by a desktop app).
    """
    if os.name == "nt":
        appdata = os.getenv("APPDATA")
        if appdata:
            return Path(appdata) / "keyvox"
    elif sys.platform == "darwin":
        return Path.home() / "Library" / "Application Support" / "keyvox"
    xdg = os.getenv("XDG_CONFIG_HOME", str(Path.home() / ".config"))
    return Path(xdg) / "keyvox"


def load_config(
    path: Path | None = None,
    *,
    quiet: bool = False,
    raise_on_error: bool = False,
) -> Dict[str, Any]:
    """Load configuration with fallback defaults.

    Args:
        path: Optional explicit config path. If omitted, auto-discovery is used.
        quiet: Suppress non-error informational logs.
        raise_on_error: Re-raise parsing/loading errors instead of falling back.
    """
    config = DEFAULT_CONFIG.copy()

    config_path = path if path is not None else _find_config_path()
    if config_path:
        try:
            with open(config_path, "rb") as f:
                user_config = tomllib.load(f)
            config = _merge_configs(config, user_config)
            if not quiet:
                print(f"[INFO] Loaded config from: {config_path}")
        except Exception as e:
            if raise_on_error:
                raise
            print(f"[WARN] Failed to load config from {config_path}: {e}")
            if not quiet:
                print("[INFO] Using default configuration")
    else:
        if not quiet:
            print("[INFO] No config.toml found, using defaults")

    return config


def save_config(path: Path, config_dict: Dict[str, Any]) -> None:
    """Save configuration to TOML file."""
    path.parent.mkdir(parents=True, exist_ok=True)

    with open(path, "w", encoding="utf-8") as f:
        f.write("# Keyvox Configuration\n")
        f.write("# Generated by setup wizard\n\n")

        for section, values in config_dict.items():
            f.write(f"[{section}]\n")
            for key, value in values.items():
                if isinstance(value, bool):
                    f.write(f"{key} = {str(value).lower()}\n")
                elif isinstance(value, str):
                    f.write(f'{key} = "{value}"\n')
                else:
                    f.write(f"{key} = {value}\n")
            f.write("\n")

    print(f"[OK] Configuration saved to: {path}")

